---
id: going-to-production-with-nginx-and-digitalocean
title: Going to production guide with Digital Ocean, Nginx, Systemd
---
import { useLatestRelease,useLatestReleaseFilename } from '@site/src/hooks'
import CodeBlock from '@theme/CodeBlock'

This guide explains how to setup and run Kratos in a
production environment. This guide covers the following topics:

- Installation and configuration of Postgres
- Installation and configuration of Kratos
- Installation and configuration of Nginx
- Installation and configuration of Kratos self-service ui

## Creating a Droplet
Spin up a droplet with the following configuration


- **OS**: Ubuntu 20.04
- **Plan**: Basic
- **CPU options**: Regular with SSD
- **RAM**: 1Gb
- **SSD**: 25Gb
- **VPC network**: default
- **Authentication**: SSH Keys. Don't forget to add your own SSH key
- **Region**: Choose your region

Wait for the ready-to-use VM and copy the IP address of your droplet

:::note
This example shows a single configuration on a small droplet.
The configuration of a droplet may vary depending on your scale
:::

This guide uses accounts.example.com as a hostname to run Kratos.
You need to configure DNS, create an `A type` record, and point it to the droplet's IP.

Let's connect to our droplet via SSH

```bash
ssh -A root@accounts.example.com
The authenticity of host 'accounts.example.com (157.245.71.211)' can't be established.
ED25519 key fingerprint is SHA256:WJsAOHk3b12Ym7keL8MHjBLjgvxfUQPhIy9pwx1czAk.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added 'accounts.example.com' (ED25519) to the list of known hosts.
Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-97-generic x86_64)
 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Fri Apr 15 07:57:35 UTC 2022

  System load:  0.31              Users logged in:       0
  Usage of /:   6.1% of 24.06GB   IPv4 address for eth0: 157.245.71.211
  Memory usage: 19%               IPv4 address for eth0: 10.18.0.5
  Swap usage:   0%                IPv4 address for eth1: 10.110.0.2
  Processes:    109

1 update can be applied immediately.
To see these additional updates run: apt list --upgradable



The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.

root@ubuntu-s-1vcpu-1gb-ams3-01:~#
```

## Installing required dependencies
As a first step, we need to upgrade all packages in our Droplet.

```bash
apt-get update && apt-get upgrade
```
The default version of nodejs is v10.19.0 on Ubuntu 20.04,
which seems outdated for today. We need to install a newer version.

```bash
curl -sL https://deb.nodesource.com/setup_16.x -o /tmp/nodesource_setup.sh
bash /tmp/nodesource_setup.sh
apt-get install nodejs npm jq unzip
```

## Installing PostgreSQL

Let's install PostgreSQL by running the following command

```bash
sudo apt install postgresql postgresql-contrib
sudo -i -u postgres
```
Let's create database

```bash
createdb kratos
```

Let's change the default password encryption to a stronger one

```bash
psql
ALTER SYSTEM SET password_encryption = 'scram-sha-256'; # Change the default password encryption to stronger one
ALTER SYSTEM

SELECT pg_reload_conf();
```

Let's create a temporary user to get a hash of a password

```bash
CREATE USER tmp_user_to_create_a_password WITH PASSWORD 'b0qw68gr3Q';

# Copy the password hash from the following command
SELECT rolpassword FROM pg_catalog.pg_authid WHERE rolname='tmp_user_to_create_a_password';

DROP USER IF EXISTS tmp_user_to_create_a_password;
```

One can create a user by running the following command

```bash
CREATE USER kratos with password 'SCRAM-SHA-256$4096:N66uuf4gEDEdvqhrInf7tw==$mnm9XgQuRIA3z8DlLa+E710GewLIDGpj2+hKyhiHOqM=:ypiPv/R1nnVc6yaiyektFuA4wnqa0xX4qjRNFKdwU2g=';
CREATE ROLE
GRANT CONNECT ON DATABASE kratos to kratos;
GRANT
```

We need to change `/etc/postgresql/12/main/pg_hba.conf` file and add the following content to enable `scram-sha-256` encryption

```
host    all             all             127.0.0.1/32            scram-sha-256
```

Let's check our credentials against PostgreSQL

```bash
psql -U kratos -W -h 127.0.0.1
Password:
psql (12.9 (Ubuntu 12.9-0ubuntu0.20.04.1))
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Type "help" for help.
```
We installed and configured PostgreSQL database and let's continue with Kratos setup

## Installing Kratos

For security reasons, we need to create a new user with prohibited login

```bash
useradd -s /bin/false -m -d /opt/kratos kratos
```
Let's create a couple of folders

```bash
mkdir /opt/kratos/{bin,config}
```
Kratos installation

<CodeBlock className="language-shell">{`cd /opt/kratos/bin
# Download a new version of Ory Kratos
wget https://github.com/ory/kratos/releases/download/${useLatestRelease('kratos')}/kratos_${useLatestReleaseFilename('kratos')}-linux_64bit.tar.gz
# Extract contents
tar xfvz kratos_${useLatestReleaseFilename('kratos')}-linux_64bit.tar.gz
# Remove redundant files
rm *md
rm LICENSE`}</CodeBlock>

Downloading configuration files
<CodeBlock className="language-shell">{`cd ../config
wget https://raw.githubusercontent.com/ory/kratos/${useLatestRelease('kratos')}/contrib/quickstart/kratos/email-password/identity.schema.json
wget https://raw.githubusercontent.com/ory/kratos/${useLatestRelease('kratos')}/contrib/quickstart/kratos/email-password/kratos.yml`}</CodeBlock>

At this point, we need to make additional configuration steps. Let's change some configuration parameters in `kratos.yml` file

```yml
dsn: postgres://kratos:b0qw68gr3Q@127.0.0.1:5432/kratos?sslmode=disable&max_conns=20&max_idle_conns=4

identity:
  default_schema_id: default
  schemas:
    - id: default
    url: file:///opt/kratos/config/identity.schema.json
```

Applying migrations

```bash
/opt/kratos/bin/kratos -c /opt/kratos/config/kratos.yml migrate sql -y postgres://kratos:b0qw68gr3Q@127.0.0.1:5432/kratos?sslmode=disable
```

Testing our setup

```bash
# /opt/kratos/bin/kratos -c /opt/kratos/config/kratos.yml serve
INFO[2022-04-15T08:24:42Z] No tracer configured - skipping tracing setup  audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
DEBU[2022-04-15T08:24:42Z] Connecting to SQL Database                    audience=application connMaxLifetime=0s idlePool=4 pool=20 service_name=Ory Kratos service_version=v0.9.0-alpha.3
WARN[2022-04-15T08:24:42Z] Config version is 'v0.7.1-alpha.1' but kratos runs on version 'v0.9.0-alpha.3'  audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
INFO[2022-04-15T08:24:42Z] Software quality assurance features are enabled. Learn more at: https://www.ory.sh/docs/ecosystem/sqa  audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
INFO[2022-04-15T08:24:42Z] TLS has not been configured for public, skipping  audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
INFO[2022-04-15T08:24:42Z] Starting the public httpd on: 0.0.0.0:4433    audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
INFO[2022-04-15T08:24:42Z] TLS has not been configured for admin, skipping  audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3
INFO[2022-04-15T08:24:42Z] Starting the admin httpd on: 0.0.0.0:4434     audience=application service_name=Ory Kratos service_version=v0.9.0-alpha.3

```

## Running Kratos using Systemd

We need to change ownker of `/opt/kratos` directory to `kratos` user

```bash
chown -R kratos /opt/kratos/
```
Let's create a `/etc/systemd/system/kratos.service` file with the following content

```
[Unit]
Description=Kratos Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=1
User=kratos
ExecStart=/opt/kratos/bin/kratos -c /opt/kratos/config/kratos.yml serve

[Install]
WantedBy=multi-user.target
```

Running kratos using systemd

```bash
# Add systemd service to startup
systemctl enable kratos.service
Created symlink /etc/systemd/system/multi-user.target.wants/kratos.service â†’ /etc/systemd/system/kratos.service.

# Start kratos service
systemctl start kratos.service

# Check running processes
ps ax | grep kratos
19191 ?        Ssl    0:00 /opt/kratos/bin/kratos -c /opt/kratos/config/kratos.yml serve
19206 ?        Ss     0:00 postgres: 12/main: kratos kratos 127.0.0.1(36094) idle

# Check if it's accessible
curl -s  http://accounts.example.com:4433/sessions/whoami|jq
{
  "error": {
    "code": 401,
    "status": "Unauthorized",
    "reason": "No valid session cookie found.",
    "message": "The request could not be authorized"
  }
}
```

We have Kratos up and running, but we need to make Kratos inaccessible via the
public internet and configure a reverse proxy. We need to set `serve.public.host`
and `serve.admin.host` to `127.0.0.1` to ensure Kratos is listening
on the loopback interface.

Change the following sections in your `kratos.yml`

```yaml
serve:
  public:
    base_url: http://127.0.0.1:4433/
    host: 127.0.0.1
    cors:
      enabled: true
  admin:
    host: 127.0.0.1
    base_url: http://kratos:4434/
```
and then restart Kratos by running

```bash
service kratos restart
curl -I http://accounts.example.com:4433
curl: (7) Failed to connect to accounts.example.com port 4433: Connection refused
```

## Installing and configuring nginx

We'll use Nginx as reverse proxy and load balancer for our service. You can install it by running

```bash
apt install nginx certbot python3-certbot-nginx
```

Let's create a default configuration for the virtual host. Let's create a `/etc/nginx/sites-avaiable/accounts.example.com` with the following content

```
server {
        listen 80;
        server_name accounts.example.com;
}
```

We need to create a symlink to `sites-enabled` directory

```bash
ln -s /etc/nginx/sites-available/accounts.example.com /etc/nginx/sites-enabled/accounts.example.com
```

Configuring SSL via Certbot. Run the following command and answer a simple questions

```bash
certbot --nginx -d accounts.example.com
```

After running certbot your configuration file will look like this

```bash
# cat /etc/nginx/sites-enabled/accounts.example.com
server {
        listen 80;
        server_name accounts.example.com;
        if ($host = accounts.example.com) {
                return 301 https://$host$request_uri;
        } # managed by Certbot
}
server {
    listen [::]:443 ssl ipv6only=on; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/accounts.example.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/accounts.example.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
```
We have configured the TLS connection with the redirect from HTTP to HTTPS by default.
 We have missing parts in our configuration, and we need to configure
 locations and [upstreams](http://nginx.org/en/docs/http/ngx_http_upstream_module.html).
One can balance network traffic between different instances of Kratos running
on the various virtual machines. We need to have two upstreams

- public_api to proxy traffic to the Public API of Ory Kratos
- admin_api to proxy traffic to the admin API of Ory Kratos

Let's add the following configuration before `server` section to `/etc/nginx/sites-enabled/accounts.example.com` file

```
upstream public_api {
        server 127.0.0.1:4433;
        server 127.0.0.1:4433; # We can load balance the traffic to support scaling
}
upstream admin_api {
        server 127.0.0.1:4434;
        server 127.0.0.1:4434;
}
server {
...
```
Let's add our locations and the `/etc/nginx/sites-enabled/accounts.example.com` has the following content

```
upstream public_api {
        server 127.0.0.1:4433;
        server 127.0.0.1:4433; # We can load balance the traffic to support scaling
}
upstream admin_api {
        server 127.0.0.1:4434;
        server 127.0.0.1:4434;
}
server {
        listen 80;
        server_name accounts.example.com;
        if ($host = accounts.example.com) {
                return 301 https://$host$request_uri;
        } # managed by Certbot
}
server {
    listen [::]:443 ssl ipv6only=on; # managed by Certbot
    listen 443 ssl; # managed by Certbot
    ssl_certificate /etc/letsencrypt/live/accounts.example.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/accounts.example.com/privkey.pem; # managed by Certbot
    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
    location / {
                proxy_pass http://public_api;
                proxy_redirect          off;
                proxy_set_header        Host            $host;
                proxy_set_header        X-Real-IP       $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    }
    location /admin {
		# Example of managing access control
		# for the /admin endpoint
		# in that example we allow access
		# either from the subnet
		# or by checking query parameter ?secret=
                set $allow 0;
		# Check against remote address
                if ($remote_addr ~* "172.24.0.*") {
                        set $allow 1;
                }
		# Check against ?secret param
                if ($arg_secret = "GuQ8alL2") {
                        set $allow 1;
                }
                if ($allow = 0) {
                        return 403;
                }

                rewrite /admin/(.*) /$1  break;

                proxy_pass http://admin_api;
                proxy_redirect          off;
                proxy_set_header        Host            $host;
                proxy_set_header        X-Real-IP       $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    location /identities {
                proxy_pass http://admin_api;
                proxy_redirect          off;
                proxy_set_header        Host            $host;
                proxy_set_header        X-Real-IP       $remote_addr;
                proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

Testing Nginx configuration and reloading it
```bash
nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

service nginx reload

curl -s  http://accounts.example.com/sessions/whoami|jq
{
  "error": {
    "code": 401,
    "status": "Unauthorized",
    "reason": "No valid session cookie found.",
    "message": "The request could not be authorized"
  }
}
```

## Installing Ory Kratos UI
The installation of KratosUI is quite simple
<CodeBlock className="language-shell">{`useradd -s /bin/false -m -d /opt/uinode uinode
wget https://github.com/ory/kratos-selfservice-ui-node/archive/refs/tags/${useLatestRelease('kratos')}.zip
unzip ${useLatestRelease('kratos')}
rm  ${useLatestRelease('kratos')}
mv kratos-selfservice-ui-node-${useLatestReleaseFilename('kratos')}/ ui
cd ui
npm i
chown -R uinode /opt/uinode
`}</CodeBlock>

Let's create a configuration file for systemd. Create `/etc/systemd/system/uinode.service` with the following content

```
[Unit]
Description=Kratos Service
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=1
User=uinode
ExecStart=/usr/bin/npm start
Environment=KRATOS_PUBLIC_URL=http://127.0.0.1:4433
Environment=KRATOS_BROWSER_URL=https://accounts.example.com
WorkingDirectory=/opt/uinode/ui

[Install]
WantedBy=multi-user.target
```
Let's enable systemd service and start it

```bash
systemctl enable uinode
Created symlink /etc/systemd/system/multi-user.target.wants/uinode.service â†’ /etc/systemd/system/uinode.service.
systemctl start uinode
```

## Changing the default Kratos configuration

In `kratos.yml` change URLs

```yaml
serve:
  public:
    base_url: https://accounts.example.com/
    host: 127.0.0.1
    cors:
      enabled: true
  admin:
    host: 127.0.0.1
    base_url: http://127.0.0.1:4434/

selfservice:
  default_browser_return_url: https://accounts.example.com/auth/
  allowed_return_urls:
    - https://accounts.example.com

  methods:
    password:
      enabled: true

  flows:
    error:
      ui_url: https://accounts.example.com/auth/errors

    settings:
      ui_url: https://accounts.example.com/auth/settings
      privileged_session_max_age: 15m

    recovery:
      enabled: true
      ui_url: https://accounts.example.com/auth/recovery

    verification:
      enabled: true
      ui_url: https://accounts.example.com/auth/verification
      after:
        default_browser_return_url: https://accounts.example.com/auth/

    logout:
      after:
        default_browser_return_url: https://accounts.example.com/auth/login

    login:
      ui_url: https://accounts.example.com/auth/login
      lifespan: 10m
```

Let's configure Nginx and add the missing configuration for Kratos UI

```
	upstream ui_node {
		server 127.0.0.1:3000;
	}
...
	location /auth {
		rewrite /auth/(.*) /$1  break;

		proxy_pass http://ui_node;
		proxy_redirect          off;
		proxy_set_header        Host            $host;
		proxy_set_header        X-Real-IP       $remote_addr;
		proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
	}
...
	error_page 401 = @error401;
	# Catch if 401/unauthorized and redirect for login
	location @error401 {
		return 302 https://accounts.example.com/auth/login;
	}

```

## Final steps

```bash
nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful

service nginx reload
```

Open https://accounts.example.com/auth/welcome
